<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Docker教程 | 小辉的折腾天地</title>

  <!-- 引入 CSS 样式 -->
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/header.css">
  <link rel="stylesheet" href="/assets/css/footer.css">
  <link rel="stylesheet" href="/assets/css/post.css">
  <link rel="stylesheet" href="/assets/css/friends.css">
  <link rel="stylesheet" href="/assets/css/blog.css">
  <link rel="stylesheet" href="/assets/css/index.css">

  <!-- 代码高亮样式 -->
  <link rel="stylesheet" href="/assets/css/code-highlight.css">

  <!-- 国内Font Awesome镜像 -->
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/7.0.0/css/all.min.css">

  <!-- === 图片点击放大功能 === -->
  <script src="https://cdn.bootcdn.net/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"></script>

  <!-- 网站图标 -->
  
  <link rel="icon" 
        href="https://cdn.tungchiahui.cn/tungwebsite/assets/images/favicon.webp">

  <!-- Vercount 网站访问统计 -->
  <script defer src="https://events.vercount.one/js"></script>

</head>

  <body>
    <header class="site-header">

  <!-- 内容层 -->
  <div class="header-content">
    <h1><a href="/">小辉的折腾天地</a></h1>
    <nav>
      <ul>
        <li><a href="/">首页</a></li>
        <li><a href="/blog/">博客</a></li>
        <li><a href="/cv/">简历</a></li>
        <li><a href="/friends/">友链</a></li>
        <li><a href="/about/">关于</a></li>
      </ul>
    </nav>
  </div>
</header>

    <main>
      <article class="post-main">
  <h2>Docker教程</h2>
  <p>
    <small>
      发布于 2024-10-03 | 作者: Tung Chia-hui | 阅读次数：<span id="vercount_value_page_pv">Loading</span> 次
    </small>
  </p>
  <div class="post-content">
    <ul id="markdown-toc">
  <li><a href="#简介" id="markdown-toc-简介">简介</a>    <ul>
      <li><a href="#-什么是-docker" id="markdown-toc--什么是-docker">🐳 什么是 Docker？</a></li>
      <li><a href="#-它是怎么工作的" id="markdown-toc--它是怎么工作的">📦 它是怎么工作的？</a></li>
      <li><a href="#-docker-的几个基本概念" id="markdown-toc--docker-的几个基本概念">🔧 Docker 的几个基本概念</a></li>
      <li><a href="#-类比理解" id="markdown-toc--类比理解">🔍 类比理解</a></li>
      <li><a href="#-docker-的核心优势" id="markdown-toc--docker-的核心优势">✅ Docker 的核心优势</a></li>
      <li><a href="#-常见-docker-应用场景" id="markdown-toc--常见-docker-应用场景">📁 常见 Docker 应用场景</a></li>
    </ul>
  </li>
  <li><a href="#安装docker" id="markdown-toc-安装docker">安装Docker</a>    <ul>
      <li><a href="#linux安装docker-engine推荐" id="markdown-toc-linux安装docker-engine推荐">Linux安装Docker Engine(推荐)</a>        <ul>
          <li><a href="#ubuntuapt" id="markdown-toc-ubuntuapt">Ubuntu（APT）</a></li>
          <li><a href="#fedoradnf5" id="markdown-toc-fedoradnf5">Fedora（DNF5）</a></li>
        </ul>
      </li>
      <li><a href="#配置环境" id="markdown-toc-配置环境">配置环境</a>        <ul>
          <li><a href="#检查-docker-服务状态-" id="markdown-toc-检查-docker-服务状态-"><strong>检查 Docker 服务状态</strong> ：</a></li>
          <li><a href="#启动-docker-服务-" id="markdown-toc-启动-docker-服务-"><strong>启动 Docker 服务</strong> ：</a></li>
          <li><a href="#设置-docker-开机自启-" id="markdown-toc-设置-docker-开机自启-"><strong>设置 Docker 开机自启</strong> ：</a></li>
          <li><a href="#将用户添加到-docker-组-" id="markdown-toc-将用户添加到-docker-组-"><strong>将用户添加到 <code class="language-plaintext highlighter-rouge">docker</code> 组</strong> ：</a></li>
          <li><a href="#退出并重新登录-" id="markdown-toc-退出并重新登录-"><strong>退出并重新登录</strong> ：</a></li>
          <li><a href="#重新启动-docker-服务如果需要-" id="markdown-toc-重新启动-docker-服务如果需要-"><strong>重新启动 Docker 服务（如果需要）</strong> ：</a></li>
          <li><a href="#重启电脑后检查-docker-服务状态-" id="markdown-toc-重启电脑后检查-docker-服务状态-"><strong>重启电脑后检查 Docker 服务状态</strong> ：</a></li>
        </ul>
      </li>
      <li><a href="#安装docker-desktopwinmac" id="markdown-toc-安装docker-desktopwinmac">安装Docker Desktop（Win，Mac）</a></li>
    </ul>
  </li>
  <li><a href="#docker直通" id="markdown-toc-docker直通">Docker直通</a>    <ul>
      <li><a href="#usb直通" id="markdown-toc-usb直通">USB直通</a></li>
      <li><a href="#nvidia显卡直通" id="markdown-toc-nvidia显卡直通">NVIDIA显卡直通</a>        <ul>
          <li><a href="#安装" id="markdown-toc-安装">安装</a>            <ul>
              <li><a href="#ubuntu" id="markdown-toc-ubuntu">Ubuntu</a></li>
              <li><a href="#fedora" id="markdown-toc-fedora">Fedora</a></li>
            </ul>
          </li>
          <li><a href="#测试是否可用" id="markdown-toc-测试是否可用">测试是否可用</a></li>
        </ul>
      </li>
      <li><a href="#docker配置cuda和cudnn" id="markdown-toc-docker配置cuda和cudnn">Docker配置CUDA和CuDNN</a></li>
      <li><a href="#配置以太网" id="markdown-toc-配置以太网">配置以太网</a></li>
    </ul>
  </li>
  <li><a href="#dockerhub换源" id="markdown-toc-dockerhub换源">DockerHub换源</a></li>
  <li><a href="#docker容器里的程序的图形界面弹不出来" id="markdown-toc-docker容器里的程序的图形界面弹不出来">docker容器里的程序的图形界面弹不出来</a></li>
  <li><a href="#docker命令学习" id="markdown-toc-docker命令学习">Docker命令学习</a>    <ul>
      <li><a href="#参考文档" id="markdown-toc-参考文档">参考文档</a></li>
      <li><a href="#常用命令" id="markdown-toc-常用命令">常用命令</a>        <ul>
          <li><a href="#run命令的参数非常重要" id="markdown-toc-run命令的参数非常重要"><strong>run命令的参数（非常重要）</strong></a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#各种docker容器部署" id="markdown-toc-各种docker容器部署">各种Docker容器部署</a>    <ul>
      <li><a href="#部署容器步骤" id="markdown-toc-部署容器步骤">部署容器步骤</a></li>
      <li><a href="#各大容器拉取" id="markdown-toc-各大容器拉取">各大容器拉取</a>        <ul>
          <li><a href="#vinci机器人队暂时主使用的docker版本" id="markdown-toc-vinci机器人队暂时主使用的docker版本">Vinci机器人队暂时主使用的docker版本</a></li>
          <li><a href="#rosopencv纯cpu版本" id="markdown-toc-rosopencv纯cpu版本">ROS+OpenCV纯CPU版本</a></li>
          <li><a href="#无rosopencv411cuda128cudnn970" id="markdown-toc-无rosopencv411cuda128cudnn970">（无ROS）OpenCV4.11+CUDA12.8+CuDNN9.7.0</a></li>
          <li><a href="#rosopencv411cuda128cudnn970" id="markdown-toc-rosopencv411cuda128cudnn970">ROS+OpenCV4.11+CUDA12.8+CuDNN9.7.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#手动创建docker镜像" id="markdown-toc-手动创建docker镜像">手动创建Docker镜像</a>    <ul>
      <li><a href="#dockerfile" id="markdown-toc-dockerfile">DockerFile</a></li>
      <li><a href="#自己创建容器" id="markdown-toc-自己创建容器">自己创建容器</a>        <ul>
          <li><a href="#手动创建" id="markdown-toc-手动创建">手动创建</a></li>
          <li><a href="#手动创建跨平台多架构构建" id="markdown-toc-手动创建跨平台多架构构建">手动创建(跨平台多架构构建)</a></li>
          <li><a href="#清除构建缓存" id="markdown-toc-清除构建缓存">清除构建缓存</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#vscode远程开发" id="markdown-toc-vscode远程开发">VScode远程开发</a></li>
</ul>

<h1 id="简介">简介</h1>

<h2 id="-什么是-docker">🐳 什么是 Docker？</h2>

<p>Docker 是一个开源的 <strong>应用容器引擎</strong> ，可以让开发者将应用和其所有依赖打包成一个“容器”，<strong>一次构建，到处运行。</strong></p>

<p>“<strong>一次构建，到处运行</strong>”也就是说：</p>

<ol>
  <li><strong>之前：</strong></li>
</ol>

<p>之前想跑ROS2+OpenCV+CUDA+CuDNN，我需要在一台电脑上一个一个环境的安装配置，如果我还要在另一台电脑上跑这个，也需要把第二台电脑也这样配置一遍。如果我的系统环境崩了，需要重装系统了，重装完后又双叒叕要再来一遍配置过程，很麻烦。</p>

<ol>
  <li><strong>使用docker后：</strong></li>
</ol>

<p>（docker镜像和docker容器的概念在下下下面，下面这段话里看到镜像和容器的概念先接受就行。）</p>

<p>我只需要在电脑上用docker配置一遍这个ROS2+OpenCV+CUDA+CuDNN环境，然后用docker生成一个镜像，把这个镜像打包好。以后在任何一台电脑上，我都可以直接用这个镜像生成一个容器，而这个容器内就包含了我所需要的ROS2+OpenCV+CUDA+CuDNN环境，如果我的容器环境崩了，我只需要把坏掉的容器删掉，重新由镜像再生成一个新的容器即可。只需要配置一次，以后都可以一键安装这个环境。</p>

<h2 id="-它是怎么工作的">📦 它是怎么工作的？</h2>

<ul>
  <li>
    <p>传统方式：软件运行需要在不同系统上安装各种库、配置环境，很麻烦。</p>
  </li>
  <li>
    <p>Docker方式：打包成“容器”，环境和应用一起封装， <strong>无论在哪运行都一样稳定</strong> 。</p>
  </li>
</ul>

<h2 id="-docker-的几个基本概念">🔧 Docker 的几个基本概念</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">概念</th>
      <th style="text-align: left">解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">镜像</td>
      <td style="text-align: left">Image，运行容器的模板，像是一个应用快照</td>
    </tr>
    <tr>
      <td style="text-align: left">容器</td>
      <td style="text-align: left">Container，运行中的镜像实例，有自己的文件系统、网络等</td>
    </tr>
    <tr>
      <td style="text-align: left">Dockerfile</td>
      <td style="text-align: left">构建镜像的脚本，写明安装哪些包、设置哪些环境变量等</td>
    </tr>
    <tr>
      <td style="text-align: left">仓库</td>
      <td style="text-align: left">Registry，存放镜像的地方，比如 Docker Hub</td>
    </tr>
  </tbody>
</table>

<p>抽象化理解:</p>

<p>Docker镜像≈C++类</p>

<p>Docker容器≈C++类实例(即对象)</p>

<p>形象化理解: 镜像可以类似于给电脑装系统的iso镜像文件。 容器可以类似于已经被装到电脑上的可以运行的系统。</p>

<p>把镜像变为容器时，需要用docker run命令添加很多参数，这个可以理解你这个电脑到底有啥硬件配置。</p>

<h2 id="-类比理解">🔍 类比理解</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">传统部署</th>
      <th style="text-align: left">Docker部署</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">手动安装依赖、调试版本不一致问题</td>
      <td style="text-align: left">一次打包环境和代码</td>
    </tr>
    <tr>
      <td style="text-align: left">程序“裸奔”跑在系统上</td>
      <td style="text-align: left">程序“穿着容器”隔离运行</td>
    </tr>
    <tr>
      <td style="text-align: left">容易“在我电脑上能跑”</td>
      <td style="text-align: left">保证“无论在哪都能跑”</td>
    </tr>
  </tbody>
</table>

<p>就像快递包裹： <strong>你不再关心内容怎么运送，因为包装已经帮你做好了一切隔离。</strong></p>

<h2 id="-docker-的核心优势">✅ Docker 的核心优势</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">优势</th>
      <th style="text-align: left">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">轻量级</td>
      <td style="text-align: left">基于系统内核共享，启动速度快，占资源少</td>
    </tr>
    <tr>
      <td style="text-align: left">跨平台</td>
      <td style="text-align: left">一次构建，到处运行（Windows、Linux、macOS 上都一致）</td>
    </tr>
    <tr>
      <td style="text-align: left">易于迁移部署</td>
      <td style="text-align: left">应用和环境一起封装，不怕依赖不一致</td>
    </tr>
    <tr>
      <td style="text-align: left">易于版本控制</td>
      <td style="text-align: left">镜像版本可控，支持回滚</td>
    </tr>
    <tr>
      <td style="text-align: left">生态丰富</td>
      <td style="text-align: left">Docker Hub 上有成千上万的现成镜像可用</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>在Linux上可以几乎实现无性能损失。</li>
</ol>

<p>docker里的发行版和本机共用Linux内核。</p>

<p>CPU损耗不到1%。 内存接近原生没损耗。 硬盘损耗不到2%。 网络性能接近原生没有损耗。 显卡损耗小于1%。</p>

<ol>
  <li>可以快速部署在绝大多数Linux发行版</li>
</ol>

<p>你想跑ROS2，之前是仅在Ubuntu上是比较好部署的，但是现在你可以使用任意发行版，比如Fedora，ArchLinux等发行版上也能通过docker跑ROS2。</p>

<ol>
  <li>配置环境简单</li>
</ol>

<p>之前你需要在Ubuntu上按照教程安装ROS2，CUDA，CuDNN，OpenCV4等等，但是只要你用了Docker，可以直接用docker pull命令拉取别人配置好的开发环境，只需要一条命令直通罗马。</p>

<p>你仅仅只需要把一个发行版最基础的东西配置好，比如那些仓库换源，输入法，显卡驱动（只用让显卡工作起来，不用在本机配置CUDA和CuDNN）等。</p>

<ol>
  <li>生态丰富</li>
</ol>

<p>生态及其丰富，有很多东西即便自己不构建，也能在dockerhub上找到别人构建好的镜像，自己连编译都省去了。</p>

<p>比如之前配置cuda和cudnn的话，需要在本机先安装英伟达驱动，再安装CUDA和CuDNN。而现在，我们只需要本机安装英伟达驱动，英伟达官方在DockerHub上提供了CUDA和CUDNN的镜像，他们已经编译好了，我们可以直接拿来用。</p>

<h2 id="-常见-docker-应用场景">📁 常见 Docker 应用场景</h2>

<ul>
  <li>
    <p>本地开发：快速搭建各种开发环境（如 Python + Jupyter、ROS + Gazebo）</p>
  </li>
  <li>
    <p>测试部署：CI/CD 中自动测试、构建、部署</p>
  </li>
  <li>
    <p>微服务架构：每个服务一个容器，灵活组合</p>
  </li>
  <li>
    <p>科研工具封装：复现别人论文环境，或封装自己的项目发给他人使用</p>
  </li>
</ul>

<h1 id="安装docker">安装Docker</h1>

<h2 id="linux安装docker-engine推荐">Linux安装Docker Engine(推荐)</h2>

<p>Linux只需要安装Docker Engine就可以，不要安装docker desktop，那玩意是专门给Mac和Windows用的。</p>

<p>Linux跑docker性能损失很低，而Windows和MacOS跑docker损失相对于大一些。</p>

<p>https://docs.docker.com/engine/install/</p>

<p>https://mirrors.bfsu.edu.cn/help/docker-ce/</p>

<h3 id="ubuntuapt">Ubuntu（APT）</h3>

<p>以下内容根据 <a href="https://docs.docker.com/engine/install/ubuntu/">官方文档</a> 修改而来。</p>

<p>如果你过去安装过 docker，先删掉：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="k">for </span>pkg <span class="k">in </span>docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc<span class="p">;</span> <span class="k">do </span><span class="nb">sudo </span>apt-get remove <span class="nv">$pkg</span><span class="p">;</span> <span class="k">done</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>首先安装依赖和GPG：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c"># Add Docker's official GPG key:</span>
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>ca-certificates curl
<span class="nb">sudo install</span> <span class="nt">-m</span> 0755 <span class="nt">-d</span> /etc/apt/keyrings
<span class="nb">sudo </span>curl <span class="nt">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/docker.gpg
<span class="nb">sudo chmod </span>a+r /etc/apt/keyrings/docker.asc

<span class="c"># 如果上面这行报错就弄下面这行</span>
<span class="nb">sudo chmod </span>a+r /etc/apt/keyrings/docker.gpg
</pre></td></tr></tbody></table></code></pre></div></div>

<p>信任 Docker 的 GPG 公钥并添加仓库：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c"># Add the repository to Apt sources:</span>
<span class="nb">echo</span> <span class="se">\</span>
  <span class="s2">"deb [arch=</span><span class="si">$(</span>dpkg <span class="nt">--print-architecture</span><span class="si">)</span><span class="s2"> signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.bfsu.edu.cn/docker-ce/linux/ubuntu </span><span class="se">\</span><span class="s2">
  "</span><span class="si">$(</span><span class="nb">.</span> /etc/os-release <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$VERSION_CODENAME</span><span class="s2">"</span><span class="si">)</span><span class="s2">" stable"</span> | <span class="se">\</span>
  <span class="nb">sudo tee</span> /etc/apt/sources.list.d/docker.list <span class="o">&gt;</span> /dev/null
</pre></td></tr></tbody></table></code></pre></div></div>

<p>最后安装</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="fedoradnf5">Fedora（DNF5）</h3>

<p>以下内容根据 <a href="https://docs.docker.com/engine/install/fedora/">官方文档</a> 修改而来。(官方教程还是DNF4,太老了，请看下方的教程)</p>

<p>如果你之前安装过 docker，请先删掉</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>dnf remove docker <span class="se">\</span>
                  docker-client <span class="se">\</span>
                  docker-client-latest <span class="se">\</span>
                  docker-common <span class="se">\</span>
                  docker-latest <span class="se">\</span>
                  docker-latest-logrotate <span class="se">\</span>
                  docker-logrotate <span class="se">\</span>
                  docker-selinux <span class="se">\</span>
                  docker-engine-selinux <span class="se">\</span>
                  docker-engine
</pre></td></tr></tbody></table></code></pre></div></div>

<p>安装依赖，下载 repo 文件，并把软件仓库地址替换为镜像站：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>dnf <span class="nt">-y</span> <span class="nb">install </span>dnf-plugins-core
<span class="nb">sudo </span>dnf config-manager addrepo <span class="nt">--from-repofile</span><span class="o">=</span>https://download.docker.com/linux/fedora/docker-ce.repo
<span class="nb">sudo sed</span> <span class="nt">-i</span> <span class="s1">'s+https://download.docker.com+https://mirrors.bfsu.edu.cn/docker-ce+'</span> /etc/yum.repos.d/docker-ce.repo
</pre></td></tr></tbody></table></code></pre></div></div>

<p>最后安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>dnf <span class="nb">install </span>docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="配置环境">配置环境</h2>

<h3 id="检查-docker-服务状态-"><strong>检查 Docker 服务状态</strong> ：</h3>

<p>在 Linux 上，你可以通过以下命令检查 Docker 服务的状态：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>systemctl status docker
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="启动-docker-服务-"><strong>启动 Docker 服务</strong> ：</h3>

<p>如果服务没有运行，可以使用以下命令启动 Docker 服务：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>systemctl start docker
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="设置-docker-开机自启-"><strong>设置 Docker 开机自启</strong> ：</h3>

<p>如果你希望 Docker 在每次启动时自动运行，可以启用开机自启：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>systemctl <span class="nb">enable </span>docker
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="将用户添加到-docker-组-"><strong>将用户添加到 <code class="language-plaintext highlighter-rouge">docker</code> 组</strong> ：</h3>

<p>使用以下命令将当前用户添加到 <code class="language-plaintext highlighter-rouge">docker</code> 组：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>usermod <span class="nt">-aG</span> docker <span class="nv">$USER</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="退出并重新登录-"><strong>退出并重新登录</strong> ：</h3>

<p>执行完上述命令后，你需要退出当前会话并重新登录，或者运行以下命令使更改生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>newgrp docker
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="重新启动-docker-服务如果需要-"><strong>重新启动 Docker 服务（如果需要）</strong> ：</h3>

<p>确保 Docker 服务正在运行，可以使用以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>systemctl start docker
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="重启电脑后检查-docker-服务状态-"><strong>重启电脑后检查 Docker 服务状态</strong> ：</h3>

<p>先重启电脑，接着你可以通过以下命令检查 Docker 服务的状态，看看是否正常：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>reboot

systemctl status docker
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image1.webp" alt="" /></p>

<h2 id="安装docker-desktopwinmac">安装Docker Desktop（Win，Mac）</h2>

<p>(Docker Desktop在Windows和MacOS使用的是虚拟机，性能有损失，在这俩系统上可以用，但是你需要接受这些性能损失。在Windows上性能损失和WSL2的损失几乎一样，因为Windows的docker desktop基于wsl2)</p>

<p>(Docker Desktop在Linux上只是Docker Engine的一个GUI管理工具，依然默认使用Docker Engine开启容器，所以依然几乎没有损耗，讨厌用命令行的可以考虑使用)</p>

<p>官方下载安装:https://www.docker.com/</p>

<p>Windows的Docker显卡直通与USB直通:</p>

<p>在Windows上想Nvidia显卡直通的话，需要先去DockerDesktop设置里开启WSL2支持并勾选一个wsl2的发行版，比如Ubuntu22.04，紧接着，需要进入wsl2的Ubuntu22.04中安装NVIDIA Container Toolkit，教程在下方。</p>

<p>在Windows的Docker上想要USB直通需要先让wsl2直通该usb，再在docker run命令将该设备添加到docker。(如果把wsl2所有设备全挂载到docker了，那么只需要让usb直通wsl2)</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image2.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image3.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image4.webp" alt="" /></p>

<h1 id="docker直通">Docker直通</h1>

<h2 id="usb直通">USB直通</h2>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image5.webp" alt="" /></p>

<ol>
  <li>方法一(不是很推荐新手)：</li>
</ol>

<p>创建容器的时候把需要的设备加在红色部分这里即可。可以通过下面的命令查看想要的设备的名字。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nb">ls</span> /dev
<span class="c">#例如</span>
<span class="nt">--device</span><span class="o">=</span>/dev/tty_USB0
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>方法二(个人更加推荐，不用重新再挂载了，虽然安全性会降低，但是别人利用安全权限能够攻击你的概率很低很低，企业服务器才需要提防)：</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nt">--privileged</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>直接添加一行绿色部分，然后所有设备都会被挂载到docker了。(红色部分就不用写了）</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image6.webp" alt="" /></p>

<h2 id="nvidia显卡直通">NVIDIA显卡直通</h2>

<p>NVIDIA Container Toolkit使用户 <strong>能够构建和运行GPU加速的容器</strong> 。该工具包包括一个容器运行库和实用程序，用于自动配置容器以利用NVIDIA GPU。</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image7.webp" alt="" /></p>

<p>https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html</p>

<h3 id="安装">安装</h3>

<p>（尽量能看官方就看官方的，安装方式可能会更新）</p>

<h4 id="ubuntu">Ubuntu</h4>

<ol>
  <li>配置存储库 并更新</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>curl <span class="nt">-fsSL</span> https://nvidia.github.io/libnvidia-container/gpgkey | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg <span class="se">\</span>
  <span class="o">&amp;&amp;</span> curl <span class="nt">-s</span> <span class="nt">-L</span> https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | <span class="se">\</span>
    <span class="nb">sed</span> <span class="s1">'s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g'</span> | <span class="se">\</span>
    <span class="nb">sudo tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list <span class="se">\</span>
  <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="nb">sudo </span>apt-get update
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>安装nvidia-docker2</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> nvidia-docker2
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>使用nvidia-ctk命令配置container runtime</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>nvidia-ctk runtime configure <span class="nt">--runtime</span><span class="o">=</span>docker
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>重启docker服务:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>systemctl restart docker
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="fedora">Fedora</h4>

<ol>
  <li>Configure the production repository:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>curl <span class="nt">-s</span> <span class="nt">-L</span> https://nvidia.github.io/libnvidia-container/stable/rpm/nvidia-container-toolkit.repo | <span class="se">\</span>
<span class="nb">sudo tee</span> /etc/yum.repos.d/nvidia-container-toolkit.repo
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>Optionally, configure the repository to use experimental packages:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>
<span class="c"># 如果是RHEL或者Rocky（DNF4）</span>
<span class="nb">sudo </span>dnf config-manager <span class="nt">--add-repo</span> https://nvidia.github.io/libnvidia-container/stable/rpm/libnvidia-container.repo

<span class="c"># 如果是Feodra41+（DNF5）</span>
<span class="nb">sudo </span>dnf config-manager addrepo <span class="nt">--from-repofile</span><span class="o">=</span>https://nvidia.github.io/libnvidia-container/stable/rpm/libnvidia-container.repo
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>Install the NVIDIA Container Toolkit packages:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>
<span class="c"># 如果是RHEL或者Rocky</span>
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> nvidia-container-toolkit

<span class="c"># 如果是Fedora</span>
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> nvidia-container-toolkit
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li><strong>安装nvidia-docker2</strong> ： 在Fedora上使用<code class="language-plaintext highlighter-rouge">dnf</code>进行安装。</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> nvidia-docker2
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li><strong>使用nvidia-ctk命令配置容器运行时</strong> ： 这个命令用于配置NVIDIA Container Toolkit与Docker集成。命令如下：</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>nvidia-ctk runtime configure <span class="nt">--runtime</span><span class="o">=</span>docker
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li><strong>重启Docker服务</strong> ： 完成配置后，必须重启Docker服务以使更改生效：</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>systemctl restart docker
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这些步骤执行后，Docker将使用NVIDIA Container Runtime，并支持GPU加速的容器运行。你可以使用<code class="language-plaintext highlighter-rouge">nvidia-smi</code>命令来验证容器中的NVIDIA GPU是否可用。</p>

<h3 id="测试是否可用">测试是否可用</h3>

<ol>
  <li><strong>运行nvidia cuda 容器进行测试</strong> ：</li>
</ol>

<p>可以使用下面指令进行测试，docker会自动从nvidia/cuda拉取11.0.3-base-ubuntu20.04镜像，并创建一个运行一次即删除的容器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">--gpus</span> all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image8.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image9.webp" alt="" /></p>

<h2 id="docker配置cuda和cudnn">Docker配置CUDA和CuDNN</h2>

<p>如果你不需要自己创建Docker镜像，直接使用学长或者其他人创建好的镜像，则不用看该章节，容器的CUDA和CuDNN是和本地完全隔离的环境，你本地有没有CUDA都无所谓，但英伟达驱动版本必须满足CUDA的最低版本要求。</p>

<p>下面是如果你想自己创建镜像，则可以在学会如何创建容器的镜像后再回来看本节：</p>

<p>https://hub.docker.com/r/nvidia/cuda</p>

<p>在上方这个网站中，英伟达都帮我们配置好了CUDA和CuDNN了，我们根本不需要自己去配置了，比传统方式要简单太多太多了。</p>

<p>我们只需要找到对应的Docker镜像当底包即可。</p>

<p>CUDA镜像有三个类型，如下，如果我们需要编译OpenCV4,那么需要使用devel版的CUDA。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">镜像类型</th>
      <th style="text-align: left">适用场景</th>
      <th style="text-align: left">示例标签</th>
      <th style="text-align: left">大小</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">base</td>
      <td style="text-align: left">仅需 CUDA 运行时库</td>
      <td style="text-align: left">12.4.0-base-ubuntu22.04</td>
      <td style="text-align: left">~240MB</td>
    </tr>
    <tr>
      <td style="text-align: left">runtime</td>
      <td style="text-align: left">部署编译后的应用（含数学库）</td>
      <td style="text-align: left">12.4.0-runtime-ubuntu22.04</td>
      <td style="text-align: left">~2GB</td>
    </tr>
    <tr>
      <td style="text-align: left">devel</td>
      <td style="text-align: left">开发环境（含编译工具）</td>
      <td style="text-align: left">12.4.0-devel-ubuntu22.04</td>
      <td style="text-align: left">~3GB</td>
    </tr>
  </tbody>
</table>

<p>我示例一个，比如我想用在Ubuntu24.04上用CUDA12.6和CuDNN，那么就选择<code class="language-plaintext highlighter-rouge">nvidia/cuda:12.6.0-cudnn-devel-ubuntu24.04</code>。这个镜像既有CUDA-devel也有CuDNN，而且还是基于Ubuntu24.04的。</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image10.webp" alt="" /></p>

<p>在dockerfile里就可以开头这么写。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>
<span class="c"># 基于NVIDIA官方CUDA 12.6和CuDNN基础镜像</span>
<span class="k">FROM</span><span class="s"> nvidia/cuda:12.6.0-cudnn-devel-ubuntu24.04</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="配置以太网">配置以太网</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nt">--net</span><span class="o">=</span>host <span class="se">\</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>启动参数里加上这行即可。具体在下方。</p>

<h1 id="dockerhub换源">DockerHub换源</h1>

<p>（DockerHub已于2024年5月被🇨🇳封杀，各大国内镜像源均已下架DockerHub镜像源，直接挂梯用官方源吧）</p>

<p>各大镜像源只有Docker-Ce的镜像库，这个是用来安装docker的，而不是dockerhub的镜像源。</p>

<h1 id="docker容器里的程序的图形界面弹不出来">docker容器里的程序的图形界面弹不出来</h1>

<p>（等你成功创建容器后，再回来搞这个操作）</p>

<p>临时允许X11访问： 每次开机在主机上运行以下命令以允许X11访问：(但每次开机都运行一遍命令很麻烦，可以写成脚本开机自启，详见<a href="https://sdutvincirobot.feishu.cn/wiki/GIKnwJo39iREkHkFGvqcy5Osntc">Vinci机器人队Linux入门教程</a>)</p>

<p>建议用systemd用户服务</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>xhost +local:docker
</pre></td></tr></tbody></table></code></pre></div></div>

<p><a href="https://sdutvincirobot.feishu.cn/wiki/GIKnwJo39iREkHkFGvqcy5Osntc">Vinci机器人队Linux入门教程</a>教程部分如下：</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image11.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image12.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image13.webp" alt="" /></p>

<h1 id="docker命令学习">Docker命令学习</h1>

<h2 id="参考文档">参考文档</h2>

<p>https://www.runoob.com/docker/docker-tutorial.html</p>

<h2 id="常用命令">常用命令</h2>

<p>常用的标红了，偶尔用的标绿了，其他了解就行。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">命令</th>
      <th style="text-align: left">描述</th>
      <th style="text-align: left">示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">docker run</td>
      <td style="text-align: left">创建并启动一个新的容器。</td>
      <td style="text-align: left">docker run -it ubuntu bash</td>
    </tr>
    <tr>
      <td style="text-align: left">docker build</td>
      <td style="text-align: left">通过指定的 Dockerfile 创建一个新的镜像。</td>
      <td style="text-align: left">docker build -t myimage .</td>
    </tr>
    <tr>
      <td style="text-align: left">docker pull</td>
      <td style="text-align: left">从 Docker 仓库拉取镜像。</td>
      <td style="text-align: left">docker pull ubuntu</td>
    </tr>
    <tr>
      <td style="text-align: left">docker push</td>
      <td style="text-align: left">将本地镜像推送到 Docker 仓库。</td>
      <td style="text-align: left">docker push myimage</td>
    </tr>
    <tr>
      <td style="text-align: left">docker stop</td>
      <td style="text-align: left">停止一个正在运行的容器。</td>
      <td style="text-align: left">docker stop container_id</td>
    </tr>
    <tr>
      <td style="text-align: left">docker start</td>
      <td style="text-align: left">启动一个已经存在的容器。</td>
      <td style="text-align: left">docker start container_id</td>
    </tr>
    <tr>
      <td style="text-align: left">docker restart</td>
      <td style="text-align: left">重新启动容器。</td>
      <td style="text-align: left">docker restart container_id</td>
    </tr>
    <tr>
      <td style="text-align: left">docker ps</td>
      <td style="text-align: left">列出当前正在运行的容器。</td>
      <td style="text-align: left">docker ps</td>
    </tr>
    <tr>
      <td style="text-align: left">docker rm</td>
      <td style="text-align: left">删除一个或多个停止的容器。</td>
      <td style="text-align: left">docker rm container_id</td>
    </tr>
    <tr>
      <td style="text-align: left">docker exec</td>
      <td style="text-align: left">在一个正在运行的容器中执行命令。</td>
      <td style="text-align: left">docker exec -it container_id bash</td>
    </tr>
    <tr>
      <td style="text-align: left">docker logs</td>
      <td style="text-align: left">查看容器的日志输出。</td>
      <td style="text-align: left">docker logs container_id</td>
    </tr>
    <tr>
      <td style="text-align: left">docker images</td>
      <td style="text-align: left">列出本地所有镜像。</td>
      <td style="text-align: left">docker images</td>
    </tr>
    <tr>
      <td style="text-align: left">docker rmi</td>
      <td style="text-align: left">删除一个或多个镜像。</td>
      <td style="text-align: left">docker rmi myimage</td>
    </tr>
    <tr>
      <td style="text-align: left">docker network</td>
      <td style="text-align: left">管理 Docker 网络。</td>
      <td style="text-align: left">docker network ls</td>
    </tr>
    <tr>
      <td style="text-align: left">docker volume</td>
      <td style="text-align: left">管理 Docker 数据卷。</td>
      <td style="text-align: left">docker volume ls</td>
    </tr>
    <tr>
      <td style="text-align: left">docker-compose up</td>
      <td style="text-align: left">启动 docker-compose.yml 中定义的所有服务。</td>
      <td style="text-align: left">docker-compose up</td>
    </tr>
    <tr>
      <td style="text-align: left">docker-compose down</td>
      <td style="text-align: left">停止并移除 docker-compose.yml 中定义的所有服务及其相关资源。</td>
      <td style="text-align: left">docker-compose down</td>
    </tr>
    <tr>
      <td style="text-align: left">docker info</td>
      <td style="text-align: left">显示 Docker 系统的详细信息。</td>
      <td style="text-align: left">docker info</td>
    </tr>
    <tr>
      <td style="text-align: left">docker stats</td>
      <td style="text-align: left">查看正在运行的容器的实时资源使用情况（CPU、内存等）。</td>
      <td style="text-align: left">docker stats</td>
    </tr>
    <tr>
      <td style="text-align: left">docker inspect</td>
      <td style="text-align: left">查看容器或镜像的详细信息（JSON 格式）。</td>
      <td style="text-align: left">docker inspect container_id</td>
    </tr>
    <tr>
      <td style="text-align: left">docker save</td>
      <td style="text-align: left">将一个镜像保存为 tar 文件。</td>
      <td style="text-align: left">docker save -o myimage.tar myimage</td>
    </tr>
    <tr>
      <td style="text-align: left">docker load</td>
      <td style="text-align: left">从 tar 文件中加载镜像。</td>
      <td style="text-align: left">docker load -i myimage.tar</td>
    </tr>
    <tr>
      <td style="text-align: left">docker tag</td>
      <td style="text-align: left">为镜像添加标签（tag）。</td>
      <td style="text-align: left">docker tag myimage myimage:v1</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx build</td>
      <td style="text-align: left">使用 Buildx 构建多架构镜像。</td>
      <td style="text-align: left">docker buildx build -t myimage .</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx create</td>
      <td style="text-align: left">创建一个新的 Buildx 构建实例。</td>
      <td style="text-align: left">docker buildx create –use</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx ls</td>
      <td style="text-align: left">列出所有可用的 Buildx 构建实例。</td>
      <td style="text-align: left">docker buildx ls</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx use</td>
      <td style="text-align: left">设置当前的 Buildx 构建实例。</td>
      <td style="text-align: left">docker buildx use mybuilder</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx bake</td>
      <td style="text-align: left">使用 Bake 文件批量构建镜像。</td>
      <td style="text-align: left">docker buildx bake -f bake.hcl</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx build –push</td>
      <td style="text-align: left">构建镜像并推送到镜像仓库。</td>
      <td style="text-align: left">docker buildx build –push -t myimage .</td>
    </tr>
    <tr>
      <td style="text-align: left">docker buildx build –platform</td>
      <td style="text-align: left">构建镜像并为多个平台生成支持。</td>
      <td style="text-align: left">docker buildx build –platform linux/amd64,linux/arm64 -t myimage .</td>
    </tr>
  </tbody>
</table>

<h3 id="run命令的参数非常重要"><strong>run命令的参数（非常重要）</strong></h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">参数/配置</th>
      <th style="text-align: left">功能说明</th>
      <th style="text-align: left">重要性与参考依据</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">–name=ros_jazzy_opencv411_cuda128_cudnn971_noble</td>
      <td style="text-align: left">指定容器名称，便于后续管理</td>
      <td style="text-align: left">替代随机生成的容器名。</td>
    </tr>
    <tr>
      <td style="text-align: left">–gpus all</td>
      <td style="text-align: left">允许容器访问宿主机所有GPU资源，需NVIDIA驱动支持</td>
      <td style="text-align: left">用于CUDA加速等GPU依赖任务。</td>
    </tr>
    <tr>
      <td style="text-align: left">-e NVIDIA_DRIVER_CAPABILITIES=all</td>
      <td style="text-align: left">启用NVIDIA驱动的全部功能（如CUDA、图形渲染）</td>
      <td style="text-align: left">确保容器内GPU功能完整67。</td>
    </tr>
    <tr>
      <td style="text-align: left">-dit</td>
      <td style="text-align: left">组合参数：- -d：后台运行容器（Detached模式）- -i：保持标准输入（STDIN）开放- -t：分配伪终端（TTY）</td>
      <td style="text-align: left">允许容器在后台运行并支持交互操作。</td>
    </tr>
    <tr>
      <td style="text-align: left">–privileged</td>
      <td style="text-align: left">赋予容器完全主机权限（可访问设备、内核模块等）</td>
      <td style="text-align: left">用于需要直接操作硬件的场景（如访问USB设备），但存在安全风险。</td>
    </tr>
    <tr>
      <td style="text-align: left">–net=host</td>
      <td style="text-align: left">共享宿主机网络命名空间（容器使用宿主机IP和端口）</td>
      <td style="text-align: left">简化网络配置，无NAT，这样的话，网络效率更高，局域网设备更容易发现。</td>
    </tr>
    <tr>
      <td style="text-align: left">–group-add audio–group-add video–group-add dialout</td>
      <td style="text-align: left">将容器用户加入宿主机用户组：- audio：音频设备访问- video：视频设备访问- dialout：串口设备访问</td>
      <td style="text-align: left">避免权限问题（如避免无法调用摄像头、麦克风）。</td>
    </tr>
    <tr>
      <td style="text-align: left">-e DISPLAY=$DISPLAY-e XAUTHORITY=/home/tungchiahui/.Xauthority-e WAYLAND_DISPLAY-e XDG_RUNTIME_DIR-e QT_QPA_PLATFORM=xcb</td>
      <td style="text-align: left">配置图形显示环境：- 绑定宿主机显示接口（X11或Wayland）- 设置GUI应用渲染后端</td>
      <td style="text-align: left">支持容器内运行图形界面应用（如OpenCV可视化）。</td>
    </tr>
    <tr>
      <td style="text-align: left">-v /tmp/.X11-unix:/tmp/.X11-unix:rw-v /dev/dri:/dev/dri</td>
      <td style="text-align: left">挂载宿主机图形设备：- X11套接字目录- 直接渲染管理器（DRI）设备</td>
      <td style="text-align: left">实现容器内图形显示。</td>
    </tr>
    <tr>
      <td style="text-align: left">-v $HOME/.Xauthority:/home/tungchiahui/.Xauthority:ro</td>
      <td style="text-align: left">挂载X11认证文件（只读）</td>
      <td style="text-align: left">确保容器有权连接宿主机显示服务。</td>
    </tr>
    <tr>
      <td style="text-align: left">-v /run/user/1000/wayland-0-v /run/user/1000</td>
      <td style="text-align: left">挂载Wayland显示协议相关目录</td>
      <td style="text-align: left">支持Wayland协议的图形显示。</td>
    </tr>
    <tr>
      <td style="text-align: left">–ulimit nofile=1024:524288</td>
      <td style="text-align: left">设置进程<strong>最大可打开文件数（nofile）</strong>的方式，用于控制容器或进程运行时的文件句柄数量限制。–ulimit <限制类型>=<软限制>:<硬限制></硬限制></软限制></限制类型></td>
      <td style="text-align: left">如果默认限制太小，可能会出现 “too many open files” 的错误。所以在容器运行或系统服务启动时，需要调大这个值。–ulimit nofile=4096:65536</td>
    </tr>
    <tr>
      <td style="text-align: left">-v /home/tungchiahui:/home/tungchiahui</td>
      <td style="text-align: left">挂载宿主机用户目录到容器内同名路径</td>
      <td style="text-align: left">实现宿主机与容器间文件共享（如代码、数据持久化）。</td>
    </tr>
    <tr>
      <td style="text-align: left">-w /home/tungchiahui</td>
      <td style="text-align: left">设置容器启动后的默认工作目录</td>
      <td style="text-align: left">直接进入项目路径，方便执行命令2324。</td>
    </tr>
    <tr>
      <td style="text-align: left">tungchiahui/ros-opencv:jazzy-411-cuda128-cudnn971-noble</td>
      <td style="text-align: left">镜像名称指定镜像及标签，包含：- ROS 2 Jazzy- OpenCV 4.11- CUDA 12.8- cuDNN 9.7.1</td>
      <td style="text-align: left">提供预配置的深度学习与机器人开发环境。</td>
    </tr>
  </tbody>
</table>

<p>下方这条命令一定要在普通用户下运行，不要在root用户下运行，其实加不加<code class="language-plaintext highlighter-rouge">sudo</code>加不加<code class="language-plaintext highlighter-rouge">sudo -E</code>都无所谓。</p>

<p>用户已经被加到docker组了，不用<code class="language-plaintext highlighter-rouge">sudo</code>也行跑，其次，<code class="language-plaintext highlighter-rouge">sudo</code>运行的话，你的<code class="language-plaintext highlighter-rouge">$HOME</code>变量也不会变，更何况加上-E的话，这样你的<code class="language-plaintext highlighter-rouge">$HOME</code>更不可能变了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="nb">sudo </span>docker run <span class="nt">--name</span><span class="o">=</span>ros_opencv_cuda <span class="se">\</span>
<span class="nt">--gpus</span> all <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">NVIDIA_DRIVER_CAPABILITIES</span><span class="o">=</span>all <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="se">\</span>
<span class="nt">-dit</span> <span class="se">\</span>
<span class="nt">--privileged</span> <span class="se">\</span>
<span class="nt">--net</span><span class="o">=</span>host <span class="se">\</span>
<span class="nt">--group-add</span> audio <span class="se">\</span>
<span class="nt">--group-add</span> video <span class="se">\</span>
<span class="nt">--group-add</span> dialout <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">XAUTHORITY</span><span class="o">=</span><span class="nv">$HOME</span>/.Xauthority <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">WAYLAND_DISPLAY</span><span class="o">=</span><span class="nv">$WAYLAND_DISPLAY</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">XDG_RUNTIME_DIR</span><span class="o">=</span><span class="nv">$XDG_RUNTIME_DIR</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">QT_QPA_PLATFORM</span><span class="o">=</span>xcb <span class="se">\</span>
<span class="nt">-v</span> /tmp/.X11-unix:/tmp/.X11-unix:rw <span class="se">\</span>
<span class="nt">-v</span> /dev/dri:/dev/dri <span class="se">\</span>
<span class="nt">-v</span> <span class="nv">$HOME</span>/.Xauthority:<span class="nv">$HOME</span>/.Xauthority:ro <span class="se">\</span>
<span class="nt">-v</span> /run/user/<span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>/wayland-0:/run/user/<span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>/wayland-0 <span class="se">\</span>
<span class="nt">-v</span> /run/user/<span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:/run/user/<span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span> <span class="se">\</span>
<span class="nt">-v</span> <span class="nv">$HOME</span>:<span class="nv">$HOME</span> <span class="se">\</span>
<span class="nt">-w</span> <span class="nv">$HOME</span> <span class="se">\</span>
tungchiahui/ros-opencv:humble-411-cuda128-cudnn970-jammy
</pre></td></tr></tbody></table></code></pre></div></div>

<p>注意：</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NVIDIA_DRIVER_CAPABILITIES=all</code> <code class="language-plaintext highlighter-rouge">--gpus all</code>没有英伟达显卡请注释。</p>
  </li>
  <li>
    <p>--name后面请自己为容器起名。</p>
  </li>
  <li>
    <p>最后一行仓库名称请你自己找对应的镜像填上。</p>
  </li>
  <li>
    <p>ROS1在Fedora发行版下会爆内存，需要添加上下面这个参数，如果你不是Fedora和ROS1,<strong><em>请不要加</em></strong>。</p>
  </li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nt">--ulimit</span> <span class="nv">nofile</span><span class="o">=</span>1024:524288 <span class="se">\</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>如果想用当前用户登陆容器,可以加上下面这几条,但非常非常<strong><em>不建议</em></strong><strong>.</strong></li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nt">--user</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="se">\</span>
<span class="nt">-v</span> /etc/passwd:/etc/passwd:ro <span class="se">\</span>
<span class="nt">-v</span> /etc/group:/etc/group:ro <span class="se">\</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="各种docker容器部署">各种Docker容器部署</h1>

<h2 id="部署容器步骤">部署容器步骤</h2>

<p>先从dockerhub拉取（docker pull）镜像，<strong>然后再通过docker run命令创建容器即可。</strong>（直接运行docker run命令也行，这会自己寻找本地镜像并创建，如果本地没有则会自动去dockerhub上寻找镜像并拉取创建容器一条龙服务。）</p>

<p>下面是各大容器拉取的命令（均支持amd64和arm64架构）：</p>

<h2 id="各大容器拉取">各大容器拉取</h2>

<h3 id="vinci机器人队暂时主使用的docker版本">Vinci机器人队暂时主使用的docker版本</h3>

<p><strong>（该版本暂未构建上传到dockerhub，但是tungchiahui/ros-opencv:humble-411-cuda128-cudnn970-jammy已经实现了下列说的全部了）</strong></p>

<p>https://hub.docker.com/repositories/sdutvincirobot</p>

<p>https://github.com/SDUTVINCI/docker</p>

<p>使用以下带有CUDA和CuDNN的Docker必须满足的条件:</p>

<ol>
  <li>
    <p>有英伟达NVIDIA独立显卡</p>
  </li>
  <li>
    <p>显卡驱动必须满足≥570.86.10</p>
  </li>
  <li>
    <p>设备的架构必须为amd64(x86_64)架构或者aarch64(arm64)架构。(绝大多数设备均满足)</p>
  </li>
  <li>
    <p>支持的显卡型号如下:</p>

    <ol>
      <li>
        <p>GTX10系列桌面端、移动端显卡均已支持</p>
      </li>
      <li>
        <p>RTX20-RTX50系列桌面端、移动端显卡均已支持</p>
      </li>
      <li>
        <p>NVIDIA Jetson AGX Orin、NVIDIA Jetson Orin NX、NVIDIA Jetson Orin Nano工控机已支持</p>
      </li>
      <li>
        <p>NVIDIA Jetson AGX Xavier、NVIDIA Jetson Xavier NX工控机已支持</p>
      </li>
      <li>
        <p>其他显卡均未适配，强行使用其他显卡肯定会有不兼容的问题，如果想要适配你的显卡型号，请单独联系学长</p>
      </li>
    </ol>
  </li>
</ol>

<p>该镜像包含的内容：</p>

<ol>
  <li>
    <p>Ubuntu22.04</p>
  </li>
  <li>
    <p>ROS2 Humble</p>
  </li>
  <li>
    <p>OpenCV4.11</p>
  </li>
  <li>
    <p>CUDA12.8</p>
  </li>
  <li>
    <p>CuDNN9.7.0</p>
  </li>
  <li>
    <p>cv_bridge(amd64支持，但arm64暂时没构建，请自行构建)</p>
  </li>
  <li>
    <p>Livox-SDK2</p>
  </li>
  <li>
    <p>(但无Livox-ROS-Driver2，自己在ws下编译吧)</p>
  </li>
</ol>

<p>请电控组成员在组长的允许下，变更该docker镜像内容，dockerfile和镜像均上传到github及dockerhub上了。</p>

<ol>
  <li>从dockerhub上拉取镜像</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>docker pull sdutvincirobot/ros-opencv:humble-411
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="rosopencv纯cpu版本">ROS+OpenCV纯CPU版本</h3>

<p>https://hub.docker.com/repository/docker/tungchiahui/ros</p>

<p>https://github.com/tungchiahui/ros-docker/blob/main/README-zh_CN.md</p>

<ol>
  <li>从dockerhub上拉取镜像</li>
</ol>

<p>暂时主要维护ROS Humble的版本，其他版本随缘更新，但也基本都是非常够用的状态（随着战队主要使用的版本而变化）</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>docker pull tungchiahui/ros:noetic-focal

docker pull tungchiahui/ros:humble-jammy

docker pull tungchiahui/ros:jazzy-noble
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="无rosopencv411cuda128cudnn970">（无ROS）OpenCV4.11+CUDA12.8+CuDNN9.7.0</h3>

<p>https://hub.docker.com/repository/docker/tungchiahui/opencv</p>

<p>https://github.com/tungchiahui/ros-docker/blob/main/README-zh_CN.md</p>

<p>OpenCV4.11+CUDA12.8+CuDNN9.7.0：</p>

<p>（因为50系显卡最低要跑CUDA12.8,所以拉高门槛）</p>

<p><a href="https://pcnveplwrxf8.feishu.cn/sync/HtRPdZxPHsfwnwbXDsjcBfVcnah">https://pcnveplwrxf8.feishu.cn/sync/HtRPdZxPHsfwnwbXDsjcBfVcnah</a></p>

<p>暂时主要维护Ubuntu Jammy的版本，其他版本随缘更新，但也基本都是非常够用的状态（随着战队主要使用的版本而变化）</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>docker pull tungchiahui/opencv:411-cuda128-cudnn970-focal

docker pull tungchiahui/opencv:411-cuda128-cudnn971-jammy

docker pull tungchiahui/opencv:411-cuda128-cudnn971-noble
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="rosopencv411cuda128cudnn970">ROS+OpenCV4.11+CUDA12.8+CuDNN9.7.0</h3>

<p>https://hub.docker.com/repository/docker/tungchiahui/ros-opencv/general</p>

<p>https://github.com/tungchiahui/ros-docker/blob/main/README-zh_CN.md</p>

<ol>
  <li>
    <p>拉取镜像：</p>

    <p>  ROS+OpenCV4.11+CUDA12.8+CuDNN9.7.0：</p>

    <p>  （因为50系显卡最低要跑CUDA12.8,所以拉高门槛）</p>

    <p>使用以下带有CUDA和CuDNN的Docker必须满足的条件:</p>

    <ol>
      <li>
        <p>有英伟达NVIDIA独立显卡</p>
      </li>
      <li>
        <p>显卡驱动必须满足≥570.86.10</p>
      </li>
      <li>
        <p>设备的架构必须为amd64(x86_64)架构或者aarch64(arm64)架构。(绝大多数设备均满足)</p>
      </li>
      <li>
        <p>cv_bridge(amd64支持，但arm64暂时没构建，请自行构建)</p>
      </li>
      <li>
        <p>支持的显卡型号如下:</p>

        <ol>
          <li>
            <p>GTX10系列桌面端、移动端显卡均已支持</p>
          </li>
          <li>
            <p>RTX20-RTX50系列桌面端、移动端显卡均已支持</p>
          </li>
          <li>
            <p>NVIDIA Jetson AGX Orin、NVIDIA Jetson Orin NX、NVIDIA Jetson Orin Nano工控机已支持</p>
          </li>
          <li>
            <p>NVIDIA Jetson AGX Xavier、NVIDIA Jetson Xavier NX工控机已支持</p>
          </li>
          <li>
            <p>其他显卡均未适配，强行使用其他显卡肯定会有不兼容的问题，如果想要适配你的显卡型号，请单独联系学长</p>
          </li>
        </ol>
      </li>
    </ol>

    <p>  暂时主要维护ROS Humble的版本，其他版本随缘更新，但也基本都是非常够用的状态随着战队主要使用的版本而变化）</p>
  </li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>docker pull tungchiahui/ros-opencv:noetic-411-cuda128-cudnn970-focal

docker pull tungchiahui/ros-opencv:humble-411-cuda128-cudnn970-jammy

docker pull tungchiahui/ros-opencv:jazzy-411-cuda128-cudnn971-noble
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="手动创建docker镜像">手动创建Docker镜像</h1>

<p><strong>（嫌麻烦的话，直接去看各种docker容器部署的章节）（有别人给你创建好的，就别自己折腾啦）</strong></p>

<h2 id="dockerfile">DockerFile</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">指令</th>
      <th style="text-align: left">说明</th>
      <th style="text-align: left">示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">FROM</td>
      <td style="text-align: left">指定基础镜像，是 Dockerfile 的起点</td>
      <td style="text-align: left">FROM ubuntu:22.04</td>
    </tr>
    <tr>
      <td style="text-align: left">LABEL</td>
      <td style="text-align: left">添加元数据（如作者、版本等）</td>
      <td style="text-align: left">LABEL maintainer=”you@example.com”</td>
    </tr>
    <tr>
      <td style="text-align: left">ENV</td>
      <td style="text-align: left">设置环境变量</td>
      <td style="text-align: left">ENV PORT=8080</td>
    </tr>
    <tr>
      <td style="text-align: left">ARG</td>
      <td style="text-align: left">构建参数，只在构建期间可用</td>
      <td style="text-align: left">ARG VERSION=1.0</td>
    </tr>
    <tr>
      <td style="text-align: left">RUN</td>
      <td style="text-align: left">构建镜像时运行命令</td>
      <td style="text-align: left">RUN apt-get update &amp;&amp; apt-get install -y curl</td>
    </tr>
    <tr>
      <td style="text-align: left">COPY</td>
      <td style="text-align: left">复制文件到镜像中</td>
      <td style="text-align: left">COPY . /app</td>
    </tr>
    <tr>
      <td style="text-align: left">ADD</td>
      <td style="text-align: left">类似 COPY，额外支持解压 .tar 文件或远程 URL（不推荐用于 URL）</td>
      <td style="text-align: left">ADD archive.tar.gz /data/</td>
    </tr>
    <tr>
      <td style="text-align: left">WORKDIR</td>
      <td style="text-align: left">设置工作目录</td>
      <td style="text-align: left">WORKDIR /opt</td>
    </tr>
    <tr>
      <td style="text-align: left">CMD</td>
      <td style="text-align: left">设置容器启动时默认命令（可被 docker run 覆盖）</td>
      <td style="text-align: left">CMD [“node”, “index.js”]</td>
    </tr>
    <tr>
      <td style="text-align: left">ENTRYPOINT</td>
      <td style="text-align: left">设置容器启动时固定命令（通常用于 CLI 工具等）</td>
      <td style="text-align: left">ENTRYPOINT [“python3”]</td>
    </tr>
    <tr>
      <td style="text-align: left">EXPOSE</td>
      <td style="text-align: left">声明镜像内服务监听的端口（不会自动映射）</td>
      <td style="text-align: left">EXPOSE 80</td>
    </tr>
    <tr>
      <td style="text-align: left">VOLUME</td>
      <td style="text-align: left">声明数据卷挂载点</td>
      <td style="text-align: left">VOLUME [“/data”]</td>
    </tr>
    <tr>
      <td style="text-align: left">USER</td>
      <td style="text-align: left">设置后续命令执行的用户</td>
      <td style="text-align: left">USER appuser</td>
    </tr>
    <tr>
      <td style="text-align: left">ONBUILD</td>
      <td style="text-align: left">当镜像作为其他镜像基础镜像时触发的构建指令</td>
      <td style="text-align: left">ONBUILD COPY . /src</td>
    </tr>
    <tr>
      <td style="text-align: left">SHELL</td>
      <td style="text-align: left">更改默认 shell，比如将 sh -c 改为 bash -c</td>
      <td style="text-align: left">SHELL [“/bin/bash”, “-c”]</td>
    </tr>
    <tr>
      <td style="text-align: left">HEALTHCHECK</td>
      <td style="text-align: left">定义容器运行时的健康检查命令</td>
      <td style="text-align: left">`HEALTHCHECK CMD curl –fail http://localhost:8080</td>
    </tr>
    <tr>
      <td style="text-align: left">STOPSIGNAL</td>
      <td style="text-align: left">容器停止时发送的信号</td>
      <td style="text-align: left">STOPSIGNAL SIGKILL</td>
    </tr>
  </tbody>
</table>

<h2 id="自己创建容器">自己创建容器</h2>

<h3 id="手动创建">手动创建</h3>

<p>https://github.com/tungchiahui/ros-docker</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>
<span class="c"># DockerFile内容请看Github仓库中的DockerFile</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在x86电脑上编译x86的：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>docker build <span class="nt">-t</span> ros-melodic-cuda118-cudnn8-bionic:latest <span class="nb">.</span>

docker build <span class="nt">-t</span> ros-noetic-focal:latest <span class="nb">.</span>

docker build <span class="nt">-t</span> ros-humble-jammy:latest <span class="nb">.</span>

docker build <span class="nt">-t</span> ros-jazzy-noble:latest <span class="nb">.</span>

docker build <span class="nt">-t</span> ros-humble-opencv411-cuda128-cudnn970-jammy:latest <span class="nb">.</span>

docker build <span class="nt">-t</span> ros-jazzy-opencv411-cuda128-cudnn970-noble:latest <span class="nb">.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image14.webp" alt="" /></p>

<p>镜像大小5GB(压缩后的大小详见DockerHub)</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image15.webp" alt="" /></p>

<p>将 Docker 镜像推送到 Docker Hub 的步骤如下：</p>

<ol>
  <li>创建 Docker Hub 账户</li>
</ol>

<p>如果你还没有 Docker Hub 账户，请前往 Docker Hub 注册一个免费账户。</p>

<ol>
  <li>登录 Docker Hub</li>
</ol>

<p>在终端中使用以下命令登录到你的 Docker Hub 账户：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>docker login
</pre></td></tr></tbody></table></code></pre></div></div>

<p>输入你的 Docker Hub 用户名和密码进行验证。</p>

<ol>
  <li>为你的镜像打标签</li>
</ol>

<p>Docker Hub 使用 <code class="language-plaintext highlighter-rouge">&lt;用户名&gt;/&lt;镜像名&gt;:&lt;标签&gt;</code> 的格式来标识镜像。你需要为你的镜像打上标签，以便能够推送到 Docker Hub。使用以下命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>docker tag ros-jazzy-noble:latest &lt;你的用户名&gt;/ros-jazzy-noble:latest
</pre></td></tr></tbody></table></code></pre></div></div>

<p>例如，如果你的 Docker Hub 用户名是 <code class="language-plaintext highlighter-rouge">tungchiahui</code>，你应该执行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>docker tag ros-noetic-focal:latest tungchiahui/ros-noetic-focal:latest

docker tag ros-humble-jammy:latest tungchiahui/ros-humble-jammy:latest

docker tag ros-jazzy-noble:latest tungchiahui/ros-jazzy-noble:latest

docker tag ros-humble-opencv411-cuda128-cudnn970-jammy:latest tungchiahui/ros-humble-opencv411-cuda128-cudnn970-jammy:latest

docker tag ros-jazzy-opencv411-cuda128-cudnn970-noble:latest tungchiahui/ros-jazzy-opencv411-cuda128-cudnn970-noble:latest
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>推送镜像到 Docker Hub</li>
</ol>

<p>使用以下命令将镜像推送到 Docker Hub：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>docker push &lt;你的用户名&gt;/ros-noetic-jazzy-noble:latest
</pre></td></tr></tbody></table></code></pre></div></div>

<p>例如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>docker push tungchiahui/ros-noetic-focal:latest

docker push tungchiahui/ros-humble-jammy:latest

docker push tungchiahui/ros-jazzy-noble:latest

docker push tungchiahui/ros-humble-opencv411-cuda128-cudnn970-jammy:latest

docker push tungchiahui/ros-jazzy-opencv411-cuda128-cudnn970-noble:latest

docker push tungchiahui/ros-noetic-focal-arm64:latest
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>验证推送成功</li>
</ol>

<p>你可以通过访问 Docker Hub 的个人页面来验证你的镜像是否已成功推送。</p>

<p><strong>注意事项</strong></p>

<ul>
  <li>
    <p>确保你的镜像大小在 Docker Hub 的限制范围内（一般为 10GB）。</p>
  </li>
  <li>
    <p>如果你打算将镜像公开，可以设置为公共仓库；如果希望只有你自己可以访问，可以设置为私有仓库。</p>
  </li>
</ul>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image16.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image17.webp" alt="" /></p>

<h3 id="手动创建跨平台多架构构建">手动创建(跨平台多架构构建)</h3>

<p>如果您想在 <strong>x86/x64 电脑上即为本机x86设备构建镜像，又想为树莓派、Jetson等ARM64 设备构建 Docker 镜像</strong> ，需要使用 <strong>Docker 的跨平台构建功能</strong> 。以下是完整解决方案：</p>

<hr />

<p>1. <strong>启用 Docker 跨平台构建</strong></p>

<p>在 x86 主机上模拟 ARM64 环境需要以下工具：</p>

<p>第一步：启用 buildx（只需执行一次）</p>

<pre><code class="language-Shell">docker buildx create --name multiarch_builder --use
</code></pre>

<p>这会创建并启用一个支持多架构构建的 builder，电脑重启后也依然存在，所以只用运行一次。</p>

<p>第二步：安装 QEMU 支持（一般新版 Docker Desktop 已自带，但是Linux必须要安装） 如果你用的是服务器或Linux发行版，确保有 qemu 模拟器：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>docker run <span class="nt">--rm</span> <span class="nt">--privileged</span> multiarch/qemu-user-static <span class="nt">--reset</span> <span class="nt">-p</span> <span class="nb">yes</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>电脑重启后，就会消失，所以需要你每次电脑重启后，在buildx命令前，运行一次该命令即可。</p>

<p>第三步：构建多架构镜像 用下面的命令构建 amd64 和 arm64：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre>docker buildx build <span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="nt">-t</span> &lt;你的镜像名&gt;:&lt;标签&gt; <span class="nt">--push</span> <span class="nb">.</span>

<span class="c"># 例子：</span>
docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/ros:noetic-focal <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/ros:humble-jammy <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/ros:jazzy-noble <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

 docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/opencv:411-cuda128-cudnn970-focal <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/opencv:411-cuda128-cudnn971-jammy <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

 docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/opencv:411-cuda128-cudnn971-noble <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/ros-opencv:noetic-411-cuda128-cudnn970-focal <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/ros-opencv:humble-411-cuda128-cudnn970-jammy <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

 docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> tungchiahui/ros-opencv:jazzy-411-cuda128-cudnn970-noble <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>

  docker buildx build <span class="se">\</span>
<span class="nt">--platform</span> linux/amd64,linux/arm64 <span class="se">\</span>
 <span class="nt">-t</span> sdutvincirobot/ros-opencv:humble-411-cuda128-cudnn970-jammy <span class="se">\</span>
 <span class="nt">--push</span> <span class="se">\</span>
 <span class="nb">.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>说明： –platform 指定多架构。 –push 是必须的，因为 buildx 的多平台构建默认是不能本地加载的（除非加 –load，但那只能支持单一架构）。</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image18.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image19.webp" alt="" /></p>

<h3 id="清除构建缓存">清除构建缓存</h3>

<pre><code class="language-C++">
# 清理BuildKit构建缓存
docker builder prune -f  
</code></pre>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image20.webp" alt="" /></p>

<h1 id="vscode远程开发">VScode远程开发</h1>

<ol>
  <li>插件1：微软Docker工具</li>
</ol>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image21.webp" alt="" /></p>

<p><em>docker扩展插件已经进化为container tools了，请安装container tools。</em></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image22.webp" alt="" /></p>

<ol>
  <li>插件2：微软Docker远程开发工具</li>
</ol>

<p>下面这是远程开发的插件。</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image23.webp" alt="" /></p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image24.webp" alt="" /></p>

<p>上述教程已经挂载了本地磁盘了，所以在Docker容器中可以轻松访问本地的工程。</p>

<p><img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/2024-10-03/image25.webp" alt="" /></p>

  </div>
</article>

<script>
// 页面内容加载完成后执行
document.addEventListener("DOMContentLoaded", function() {

  const imgs = document.querySelectorAll('.post-content img');

  imgs.forEach(img => {
    // 如果图片还没有 data-src，就把 src 移过去
    if (!img.dataset.src) {
      img.dataset.src = img.src; 
      img.removeAttribute('src'); 
    }
  });

  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;

        if (img.dataset.src) {
          img.src = img.dataset.src;
          img.removeAttribute('data-src');

          // ✅ 新增：当图片真正加载完成后，触发自定义事件
          img.addEventListener('load', () => {
            const event = new CustomEvent('lazyloaded', { detail: { img } });
            document.dispatchEvent(event);
          }, { once: true });
        }

        obs.unobserve(img);
      }
    });
  }, {
    root: null,           
    rootMargin: '666px 0px',
    threshold: 0          
  });

  imgs.forEach(img => observer.observe(img));
});
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll('div[class*="language-"].highlighter-rouge').forEach((highlightDiv) => {
    const codePre = highlightDiv.querySelector('td.rouge-code pre');
    if (!codePre) return;

    // 创建复制按钮
    const button = document.createElement('button');
    button.className = 'copy-button';
    button.type = 'button';
    button.innerText = '复制';

    button.addEventListener('click', () => {
      const text = codePre.innerText.trim();
      navigator.clipboard.writeText(text).then(() => {
        button.innerText = '已复制';
        setTimeout(() => button.innerText = '复制', 2000);
      });
    });

    // 挂到 highlightDiv 上，保证按钮固定在代码框右上角
    highlightDiv.style.position = 'relative';   // 父容器相对定位
    button.style.position = 'absolute';
    button.style.top = '8px';
    button.style.right = '8px';
    button.style.padding = '4px 8px';
    button.style.fontSize = '0.8em';
    button.style.cursor = 'pointer';

    highlightDiv.appendChild(button);
  });
});
</script>

<!-- === 图片点击放大效果 === -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // 选择文章正文内所有图片
  const images = document.querySelectorAll('.post-content img');

  // 过滤掉代码块或表格中不需要放大的图片
  const validImages = Array.from(images).filter(img => {
    return !img.closest('pre, code, table');
  });

  // 初始化 Medium Zoom
  const zoom = mediumZoom(validImages, {
    margin: 24, // 放大时边距
    background: 'rgba(0,0,0,0.8)', // 背景遮罩色
    scrollOffset: 40 // 滚动多少距离后关闭放大
  });

  // 如果页面启用了懒加载，当懒加载触发时重新绑定放大事件
  document.addEventListener('lazyloaded', () => {
    zoom.detach(); // 先解除旧绑定
    zoom.attach('.post-content img'); // 重新绑定新加载的图片
  });
});
</script>




    </main>

    <footer>
  <p>© 2025 小辉的折腾天地. All rights reserved.</p>

  <!-- 社交图标 -->
  <div class="footer-social">
    
      <a href="https://me.tungchiahui.cn" target="_blank" rel="noopener" title="Website">
        <i class="fas fa-link"></i>
      </a>
    
    
      <a href="mailto:tungchiahui@gmail.com" target="_blank" rel="noopener" title="E-Mail">
        <i class="fas fa-envelope"></i>
      </a>
    
    
      <a href="https://github.com/tungchiahui" target="_blank" rel="noopener" title="GitHub">
        <i class="fab fa-github"></i>
      </a>
    
    
      <a href="https://qm.qq.com/q/JRhksaNK82?from=qq" target="_blank" rel="noopener" title="QQ">
        <i class="fab fa-qq"></i>
      </a>
    
    
      <a href="https://t.me/tungchiahui" target="_blank" rel="noopener" title="Telegram">
        <i class="fab fa-telegram"></i>
      </a>
    
    
      <a href="http://www.coolapk.com/u/3224578" target="_blank" rel="noopener" title="CoolAPK">
        <i class="fab fa-android"></i>
      </a>
    
    
      <a href="https://space.bilibili.com/141482453" target="_blank" rel="noopener" title="Bilibili">
        <i class="fa-brands fa-bilibili"></i>
      </a>
    
    
      <a href="https://www.youtube.com/@Chia-huiTung" target="_blank" rel="noopener" title="YouTube">
        <i class="fab fa-youtube"></i>
      </a>
    
    
      <a href="https://twitter.com/tungchiahui" target="_blank" rel="noopener" title="Twitter">
        <i class="fab fa-twitter"></i>
      </a>
    
    
      <a href="https://www.facebook.com/tungchiahui" target="_blank" rel="noopener" title="Facebook">
        <i class="fab fa-facebook"></i>
      </a>
    
    
      <a href="https://www.instagram.com/tungchiahui" target="_blank" rel="noopener" title="Instagram">
        <i class="fab fa-instagram"></i>
      </a>
    
  </div>

  <div class="footer-records">
    <!-- ICP 备案号 -->
    
    <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener" class="footer-record icp">
      <img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/footer/favicon-miit.ico" alt="工信部图标">
      鲁ICP备2025185601号-2
    </a>
    

     <!-- 公安备案号 -->
    
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=xxxxxxxxxxx" target="_blank" rel="noopener" class="footer-record beian">
      <img src="https://cdn.tungchiahui.cn/tungwebsite/assets/images/footer/favicon-mps.ico" alt="公安备案图标">
      鲁公网安备 xxxxxxxxxxx 号
    </a>
    
  </div>


</footer>


    <!-- 这才是liquild的注释，不能用html的注释 -->
    <!-- 因为liquid会把html的注释也渲染出来 -->
    

  </body>
</html>
