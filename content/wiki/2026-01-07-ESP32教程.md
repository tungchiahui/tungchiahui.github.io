---
title: ESP32教程
date: 2026-01-07
path: /wiki/esp32-tutorial
---


## 简介

## ESP32环境搭建
### Linux
打开下面的网站,
https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/linux-macos-setup.html

#### 安装依赖
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767934049542.webp)

第一步按照这个网站所示,如果你是Ubuntu

```bash
sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
```

如果你是Fedora

```bash
sudo dnf -y makecache && sudo dnf install git wget flex bison gperf python3 python3-setuptools cmake ninja-build ccache dfu-util libusbx
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767934192251.webp)

#### 获取 ESP-IDF

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767934330673.webp)

看看目前最新稳定版是哪个版本

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767934480759.webp)

如上图所示,为5.5.2版本.
接下来,你选择一个你要存放固件的文件夹,
比如我要放在/home/tungchiahui/UserFolder/Applications/文件夹下(其中`/home/tungchiahui`可用`~/`代替)
那么

```bash
cd ~/UserFolder/Applications
mkdir -p ./esp
cd ./esp
# 记得版本号要改成最新稳定版(网络环境一定要好)
git clone -b v5.5.2 --recursive https://github.com/espressif/esp-idf.git
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767934869161.webp)

如图才是成功,不是下面这样的都是没下载成功的
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767935331654.webp)


#### 设置工具
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767934989357.webp)

```bash
cd ./esp-idf
# 选择国内服务器
export IDF_GITHUB_ASSETS="dl.espressif.cn/github_assets"
./install.sh all
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767935447878.webp)


![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767935597546.webp)

上图就是成功的样子,这里要复制一下我红色圈起来的东西(`export.sh`的路径),下一个环境配置中要使用,比如我这里复制下来的路径是
`~/UserFolder/Applications/esp/esp-idf/export.sh`


#### 设置环境变量
此时，刚刚安装的工具尚未添加至 PATH 环境变量，无法通过“命令窗口”使用这些工具。因此，必须设置一些环境变量。这可以通过 ESP-IDF 提供的另一个脚本进行设置。

```bash
vim ~/.bashrc
```

添加下面这句(这里要填你具体存放的路径,也就是刚才复制的那串路径,记得把`~`改成`$HOME`,增加健壮性)
```bash
alias get_idf='. $HOME/UserFolder/Applications/esp/esp-idf/export.sh'
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767935820486.webp)

```bash
source ~/.bashrc
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767935970620.webp)


#### 配置VScode
https://docs.espressif.com/projects/vscode-esp-idf-extension/zh_CN/latest/index.html

1. 安装ESP-IDF插件

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936248029.webp)

2. 点击 Express 并选择下载服务器：

按下图的选,因为我们刚才配置过环境了,这里不要再选择版本了,直接去选择从我的电脑里找到ESP-IDF

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936512526.webp)

他会自动帮你补全所有工具链

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936567868.webp)

右下角这么显示则为成功

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936602550.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936647403.webp)


紧接着要配置 openOCD :
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936736342.webp)
复制上面这行,并开终端(任意终端都行,不用管路径)运行

```bash
sudo cp --update=none /home/tungchiahui/.espressif/tools/openocd-esp32/v0.12.0-esp32-20250707/openocd-esp32/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1767936805629.webp)

结束!

### Windows
打开下面的网站,
https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/windows-setup.html

#### 下载安装程序
查看当前最新版，比如我这里最新版是v5.5.2
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097572869.webp)

点击工具下载
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097420298.webp)

并点击最新版的安装，比如我这里最新版是v5.5.2

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097535450.webp)

#### 安装ESP-IDF
点击下载好的esp-idf
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097744578.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097780350.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097800892.webp)

选择你想安装的硬盘分区，比如我要安装在`C:\Espressif`，那就是如下图这样。
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097823822.webp)
如果你想安装在D盘，就把第一个C改成D。
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097881504.webp)

把这些没勾的全部勾上，点安装
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768097941290.webp)

然后点完成
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099670485.webp)

弹出来的框都这么显示，则是成功安装了
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099702456.webp)

#### 配置环境
随便打开一个文件夹，右键`This PC（此电脑）`，点`属性`
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099767864.webp)

这里有个高级系统设置
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099838542.webp)

点环境变量
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099861401.webp)


点击新建
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099886239.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099909017.webp)

找到刚才安装idf的目录里的这个目录点确定

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099932086.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768099957136.webp)

#### 配置VScode

安装下面这个插件

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100027759.webp)

安装完毕后，点击打开开始向导

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100049539.webp)

点击第一个
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100080553.webp)


按我这么来，然后点安装
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100238920.webp)

这个界面就是安装成功
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100445841.webp)

#### 下载串口驱动
打开下面这个网站
https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/establish-serial-connection.html

1. CP210x驱动

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100660387.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100674154.webp)

解压刚才下载的压缩包
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100712206.webp)

右键`silabser.inf`点击`安装`
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100816094.webp)
安装完毕
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100839744.webp)

2. FTDI驱动

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768101118029.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768101142315.webp)

同样解压下载好的压缩包

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768101174406.webp)

分别右键下面这俩，点安装

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768101274422.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100839744.webp)

3. CH340驱动
打开下面的网站
https://www.wch.cn/products/ch340.html

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100958652.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768100976886.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768101016790.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768101038694.webp)


## 参考视频

https://www.bilibili.com/video/BV1EPisBWEUX

## 教程

下面教程我以ESP32S3和Fedora Linux为例.

**本教程特点是,虽然大部分基于正点原子教程,但是正点原子教程用了非常多的宏定义,这并不适合新手进行阅读,本教程会尽量少用宏定义,尽量能够把最原本的代码教给你.**


### 基础工程创建

#### 准备工作
(一些老版本必须移动这个文件夹)
复制一下这个文件夹`esp-idf/tools/templates/sample_project`

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768314488557.webp)

复制到这里`esp-idf/examples/get-started/sample_project`
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768314551666.webp)

#### 创建新工程

点击`New Projects`
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768314732108.webp)


![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768314940430.webp)

下面这俩选哪个都行,一些老版本没有最底下那个选项.(正常最新版选最底下那个就行)
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768315043852.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768315170936.webp)

创建成功

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316173024.webp)

#### menuconfig配置

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316263151.webp)

1. 配置主频
搜索`CPU`,找到CPU主频的设置,设置CPU主频为240MHz(最大)
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316286100.webp)

2. 配置Flash和RAM

搜`Flash`,设置`Flash SPI mode`为QIO,这种模式下速度最快.

查看淘宝自己买的ESP32S3型号,`ESP32-S3 N16R8`得知我的Flash为16M,RAM为8M

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316646459.webp)

搜`PSRAM`并打勾

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316691252.webp)

查看官方给的PSRAM介绍,我们应该选`Octal SPI`

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316801358.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316830677.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316860867.webp)

3. 配置FreeRTOS

将`configTICK_RATE_HZ`配置为`1000`,这样周期为1ms,`vTaskDelay()`函数的单位也就变成了ms.
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768316998368.webp)

4. 配置分区表
搜`partition`,找到`partition table`,并配置为`自定义分区表CSV`
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317232438.webp)

5. 保存
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317262632.webp)

旧的备份可以删掉
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317292811.webp)

6. 编辑分区表
ctrl shift P一起摁,输入`Partition Table`,找到`Open Partition Table Eidtors UI`

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317456014.webp)

按照下面一点都别抄错的抄下来
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317821742.webp)

可以看到都生成完毕了
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317884257.webp)

7. 编译测试

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317920177.webp)

如图则为编译成功

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768317956841.webp)


### 分区表简介

分区表作用是将Flash分为多个存储区域,记录每个区域的特定功能和用途.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768364806657.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768364833756.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768364863022.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768364885473.webp)

### 自定义工程架构及添加组件

#### 介绍工程架构

以下是乐鑫官方的工程结构:

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768364924079.webp)

这种明显是很杂糅的

以下是正点原子的工程结构,更加模块化,扩展性更灵活,分层更清晰.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768365242442.webp)

#### 创建工程架构

复制basic工程,并粘贴到你存放代码的文件夹,然后重命名为N01_LED.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768365712006.webp)

用VScode打开新创建的文件夹
```bash
cd ~/UserFolder/MySource/ESP32_Projects/N01_LED
code .
```
创建以下文件

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374450746.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374502096.webp)

打开顶层CMakeLists

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768373817706.webp)

```cmake
# Set the extra component directories
set(EXTRA_COMPONENT_DIRS components/Middlewares)

# Add compile options,warning has color.
add_compile_options(-fdiagnostics-color=always)
```

修改BSP里的CMakeLists

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374173407.webp)

```cmake
set(src_dirs
			LED)

set(include_dirs
			LED)

# GPIO的一些组件在driver里
set(requires
			driver)

idf_component_register(SRC_DIRS ${src_dirs}
					  INCLUDE_DIRS ${include_dirs} REQUIRES ${requires})

component_compile_options(-ffast-math -O3 -Wno-error=format=-Wno-format)
```

清理再编译看看
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374290311.webp)

成功编译

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374519751.webp)

#### 添加组件

ctrl shift P搜索`esp component`找到`esp component registry`
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374757763.webp)

选择型号
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374798596.webp)

例如要安装OpenAI,则搜索OpenAI

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374854035.webp)

点安装

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374870553.webp)

安装成功

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374895177.webp)

下图所示就是安装成功
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374968925.webp)

清理再编译看看
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374290311.webp)

成功编译

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768374519751.webp)

注意,在`main.c`里可以直接调用添加的组件,但在`components`文件夹下的文件里,不可以直接用,要修改`CMakeLists.txt`

### ESP32的下载与调试

#### 下载

先写一个程序,在main.c里写个helloworld.
```c
#include <stdio.h>

void app_main(void)
{
    printf("Hello World!\n");
}
```


你用一根USB-A转USB-C的数据线,一头在电脑上,一头插到开发板的USB接口,而不是UART接口.

如图


1. 查找设备
    1. Windows
    如果你是windows,则右键`此电脑`,点`管理`

    ![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768375429763.webp)

    看到下面正常检测出来了

    ![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768375466417.webp)

    2. Linux
    如果你是linux,则打开终端

    ```bash
    ls /dev | grep USB
    ```

    看是否有设备被检测出来.(也有可能被检测为ACM了,反正你也可以直接`ls /dev`查看设备)

2. 下载
    1. Windows
    如果你是Windows,则要先选模式为`JTAG`,端口为检测出来的端口`COM4`,芯片型号为`esp32s3`,然后点击`清理`,`构建`,`烧录`.

    ![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768375800452.webp)

    然后选择yes

    ![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768375960461.webp)


    如图烧录好了

    ![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768376077047.webp)

   2. Linux
    如果你是Linux,则要先选模式为`JTAG`,端口为检测出来的端口`/dev/ttyUSB0`,芯片型号为`esp32s3`,然后点击`清理`,`构建`,`烧录`.

#### 调试

先写一个程序

```c
#include <stdio.h>

void app_main(void)
{
    printf("Hello World!\n");
}
```

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768376418125.webp)

下图,
第一个是开始运行.
第二个是逐过程,一个函数一个函数的运行.
第三个是单步调试,他会进入函数内部执行.
第四个是单步跳出,会跳出这个函数.
第五个是重启程序,但在esp32里有bug,貌似不会重启,不知道后续是否会修.
第六个是断开链接,退出调试.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768376495953.webp)

也可以打断点,这样程序运行到断点处就不会接着运行了.
如图



然后也可以右键一个变量,把他添加到Watch,在程序某行打断点,来看程序运行到这一行前(注意,这里是在哪行打断点,就是刚运行到哪行,那一个还没有运行呢),这个变量的值为多少.
如图


### ESP32-S3的时钟树

#### 时钟

时钟是一个周期性翻转的信号
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768377363665.webp)

每来一次时钟边沿,整个电路就会完整一次状态的更新,
这样,整个系统就会往前一步.

#### 时钟树

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768377731446.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768377775953.webp)

OSC是高速晶振,CLK是时钟,PLL是锁相环,图里的DIV是分频器,MUX是选择器.
OSC要接晶振.
CLK是可用的时钟信号.
PLL为了被倍频或者分频的时钟频率.
DIV为了省电,节约资源.
MUX是选择哪一个时钟源.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768378403104.webp)

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768378429705.webp)


### GPIO

#### GPIO理论

实际上就是通用输入输出端口的意思,可以输出高低电平,也可以读取高低电平.

输入的原理,就是如下图,如果KEY按下会让电路电平变为低,那就要上拉电阻,用下降沿来判断按键是否按下.
由于上拉电阻,所以刚开始KEY没按下的时候下方电路的IO口那边是高电平,一旦KEY按下,将会变成低电平,这样就会有一个下降沿(电平由高变低).

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768390289518.webp)

输出,如下图,当IO为高电平的时候,LED发光二极管导通,然后LED亮,当IO为低电平的时候,LED发光二极管不导通,LED灭.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768390481849.webp)


以下是ESP32的IO:

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768391351684.webp)

他们是高度复用的,每一个都可以复用成其他外设的接口.

但有些特例,有些引脚不可以当输出输入,他们只能用来连接模块上的FLASH或PSRAM.
可以看正点原子的`esp32-s3_datasheet_cn.pdf`里的详细说明.

#### GPIO相关函数

1. **gpio_config**

这个是GPIO初始化函数
```c
esp_err_t gpio_config(const gpio_config_t *pGPIOConfig)
```



然后你右键选中`gpio_config_t`,点`go to definition`,就会出现下面这个是GPIO初始化函数里的入口参数的结构体
```c
/**
 * @brief Configuration parameters of GPIO pad for gpio_config function
 */
typedef struct {
    uint64_t pin_bit_mask;          /*!< GPIO pin: set with bit mask, each bit maps to a GPIO */
    gpio_mode_t mode;               /*!< GPIO mode: set input/output mode                     */
    gpio_pullup_t pull_up_en;       /*!< GPIO pull-up                                         */
    gpio_pulldown_t pull_down_en;   /*!< GPIO pull-down                                       */
    gpio_int_type_t intr_type;      /*!< GPIO interrupt type                                  */
#if SOC_GPIO_SUPPORT_PIN_HYS_FILTER
    gpio_hys_ctrl_mode_t hys_ctrl_mode;       /*!< GPIO hysteresis: hysteresis filter on slope input    */
#endif
} gpio_config_t;
```
`pin_bit_mask`是用于设置你要配置的GPIO引脚,一般为`1ull << x`,这里的`x`就是你要设置的GPIO的`IOx`号.<br>

`mode`是配置输入还是输出的模式,你可以`go to definition`看看`gpio_mode_t`.<br>

```c
typedef enum {
    GPIO_MODE_DISABLE = GPIO_MODE_DEF_DISABLE,                                                         /*!< GPIO mode : disable input and output             */
    GPIO_MODE_INPUT = GPIO_MODE_DEF_INPUT,                                                             /*!< GPIO mode : input only                           */
    GPIO_MODE_OUTPUT = GPIO_MODE_DEF_OUTPUT,                                                           /*!< GPIO mode : output only mode                     */
    GPIO_MODE_OUTPUT_OD = ((GPIO_MODE_DEF_OUTPUT) | (GPIO_MODE_DEF_OD)),                               /*!< GPIO mode : output only with open-drain mode     */
    GPIO_MODE_INPUT_OUTPUT_OD = ((GPIO_MODE_DEF_INPUT) | (GPIO_MODE_DEF_OUTPUT) | (GPIO_MODE_DEF_OD)), /*!< GPIO mode : output and input with open-drain mode*/
    GPIO_MODE_INPUT_OUTPUT = ((GPIO_MODE_DEF_INPUT) | (GPIO_MODE_DEF_OUTPUT)),                         /*!< GPIO mode : output and input mode                */
} gpio_mode_t;
```

其他的也一样,你都可以`go to definition`来看这个结构体到底能填什么.

`pull_up_en`是是否使能上拉电阻,就是讲IO那条电路再并联一条上面有一个电阻和VCC的电路.<br>
`pull_down_en`是是否使能下拉电阻,就是讲IO那条电路再并联一条上面有一个电阻和GND的电路.<br>

`intr_type`是是否启用中断类型.<br>

2. **gpio_set_level**

```c
esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level)
{
    GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), "GPIO output gpio_num error", ESP_ERR_INVALID_ARG);
    gpio_hal_set_level(gpio_context.gpio_hal, gpio_num, level);
    return ESP_OK;
}
```
`gpio_num`是选择哪一个IO口,可以`go to definition`看一看,如下面的代码可知,他可以填`GPIO_NUM_x`,这里的`x`就是选择初始化`IOx`(也就是初始化哪一个引脚IO)<br>

`level`是输出的电平是高还是低,填0就是低,填1就是高.

```c
/**
 * @brief GPIO number
 */
typedef enum {
    GPIO_NUM_NC = -1,    /*!< Use to signal not connected to S/W */
    GPIO_NUM_0 = 0,     /*!< GPIO0, input and output */
    GPIO_NUM_1 = 1,     /*!< GPIO1, input and output */
    GPIO_NUM_2 = 2,     /*!< GPIO2, input and output */
    GPIO_NUM_3 = 3,     /*!< GPIO3, input and output */
    GPIO_NUM_4 = 4,     /*!< GPIO4, input and output */
    GPIO_NUM_5 = 5,     /*!< GPIO5, input and output */
    GPIO_NUM_6 = 6,     /*!< GPIO6, input and output */
    GPIO_NUM_7 = 7,     /*!< GPIO7, input and output */
    GPIO_NUM_8 = 8,     /*!< GPIO8, input and output */
    GPIO_NUM_9 = 9,     /*!< GPIO9, input and output */
    GPIO_NUM_10 = 10,   /*!< GPIO10, input and output */
    GPIO_NUM_11 = 11,   /*!< GPIO11, input and output */
    GPIO_NUM_12 = 12,   /*!< GPIO12, input and output */
    GPIO_NUM_MAX,
} gpio_num_t;
```

3. **gpio_get_level**

```c
int gpio_get_level(gpio_num_t gpio_num)
{
    return gpio_hal_get_level(gpio_context.gpio_hal, gpio_num);
}
```

`gpio_num`是选择哪一个IO口,可以`go to definition`看一看,如下面的代码可知,他可以填`GPIO_NUM_x`,这里的`x`就是选择初始化`IOx`(也就是初始化哪一个引脚IO)<br>

return返回的int的数据是读取到的电平是高还是低,0就是低,1就是高.

#### LED灯实战
两种LED实物:
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768393817874.webp)
贴片LED
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768393873412.webp)


下面这个电路中IO口端是高电平的时候LED才亮.
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768394340551.webp)
下面这个电路中IO口端是低电平的时候LED才亮.
![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768394377192.webp)
上面这俩缺点是电流直接走MCU,有另一种三极管的方法更加好,可以自己搜搜,或者看一下大疆STM32C板(STM32F407IGH6)的原理图.

先来编写`led.h`的代码,这个是最小的框架,你应该学过C语言的条件编译,这是为了让头文件不会重复.
```c
#ifndef __LED_H_
#define __LED_H_



#endif
```

接下来继续完善`led.h`,下面这个枚举是为了让代码可读性更高,给高低电平起了个名字,`PIN_RESET`为低电平,`PIN_SET`为高电平.
```c
#ifndef __LED_H_
#define __LED_H_

//包含ESP32的gpio组件的头文件
#include "driver/gpio.h"

typedef enum {
    PIN_RESET = 0,     
    PIN_SET      
} gpio_output_state_t;

void led_init(void);

#endif
```


接下来再编写`led.c`的内容:
由于看我自己板子的原理图,我的板子的IO13是LED灯的控制引脚,所以下面我初始化IO13.

```c
#include "led.h"

void led_init(void)
{   
    //给结构体清零(C语言知识,要给局部变量清零,防止未被初始化的地方出现很奇怪的事情)
    gpio_config_t gpio_init_struct = {0}; 

    gpio_init_struct.pin_bit_mask = (1ULL << GPIO_NUM_13);    //初始化IO13
    gpio_init_struct.mode = GPIO_MODE_OUTPUT;                 //设置为输出模式
    gpio_init_struct.pull_up_en = GPIO_PULLUP_DISABLE;        //禁用上拉电阻
    gpio_init_struct.pull_down_en = GPIO_PULLDOWN_DISABLE;    //禁用下拉电阻
    gpio_init_struct.intr_type = GPIO_INTR_DISABLE;           //禁用中断

    gpio_config(&gpio_init_struct);        //配置GPIO

}
```
上面这些参数你该填什么,都可以通过`go to definition`查询结构体类型来得知.
不懂的详细看看正点原子视频怎么查询结构体.<br>

然后再编辑一下`main.c`:
```c
//包含FreeRTOS头文件(为了用vTaskDelay)
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
//包含LED头文件,为了初始化LED和使用GPIO
#include "led.h"

void app_main(void)
{
    //初始化led的GPIO
    led_init();
    //死循环,等同于while(1),但效率比while(1)更高
    for(;;)
    {
        gpio_set_level(GPIO_NUM_13, PIN_SET);   //设置为高电平
        vTaskDelay(500 / portTICK_PERIOD_MS);  //延时500ms
        gpio_set_level(GPIO_NUM_13, PIN_RESET); //设置为低电平
        vTaskDelay(500 / portTICK_PERIOD_MS);  //延时500ms
    }
}
```
以上代码会让LED每隔1s闪烁一次.
这里的
`vTaskDelay(500 / portTICK_PERIOD_MS);`其实可以简化为`vTaskDelay(500);`,因为咱们之前配置过`configTICK_RATE_HZ`为1000,这样会导致`portTICK_PERIOD_MS`的值为1.<br>
但上面的写法更加正规,如果其他人想用你的代码,别人也不会让延迟跑错单位.还是推荐不要简化的办法,而正点原子是简化后的,如果别人迁移复制你的代码,会出大问题的.<br>

老三样,依次摁,然后可以看到板子上的灯会闪烁.

![alt text](https://cdn.tungchiahui.cn/tungwebsite/assets/images/2026/01/07/1768396481018.webp)




#### KEY实战